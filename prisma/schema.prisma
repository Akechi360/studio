generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  User
  Admin
  Presidente
}

model User {
  id                        String                @id @default(cuid())
  name                      String
  email                     String                @unique
  password                  String // Will store hashed password
  role                      Role                  @default(User)
  avatarUrl                 String?
  department                String?
  createdAt                 DateTime              @default(now())
  updatedAt                 DateTime              @updatedAt

  ticketsCreated            Ticket[]              @relation("TicketsCreatedByUser")
  comments                  Comment[]
  inventoryItemsAdded       InventoryItem[]       @relation("InventoryAddedByUser")
  approvalRequestsCreated   ApprovalRequest[]     @relation("ApprovalRequestedByUser")
  approvalRequestsApproved  ApprovalRequest[]     @relation("ApprovalApprovedByUser")
  auditLogEntries           AuditLogEntry[]
  casosMantenimientoRegistered CasoDeMantenimiento[] @relation("CasoRegisteredByUser")
  casosMantenimientoLogEntries CasoMantenimientoLogEntry[] @relation("LogEntryByUser")


  @@index([email])
}

enum TicketPriority {
  Low
  Medium
  High
}

enum TicketStatus {
  Open
  InProgress
  Resolved
  Closed
}

model Ticket {
  id          String         @id @default(cuid())
  subject     String
  description String         @db.Text
  priority    TicketPriority
  status      TicketStatus
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  userId      String
  user        User           @relation("TicketsCreatedByUser", fields: [userId], references: [id])
  userName    String // Denormalized for easier display
  userEmail   String?
  comments    Comment[]
  attachments Attachment[]

  @@index([userId])
  @@index([status])
  @@index([priority])
}

model Comment {
  id        String   @id @default(cuid())
  text      String   @db.Text
  createdAt DateTime @default(now())

  ticketId  String
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  userId    String
  user      User     @relation(fields: [userId], references: [id])
  userName  String // Denormalized
  userAvatarUrl String?
  @@index([ticketId])
  @@index([userId])
}

model Attachment {
  id       String  @id @default(cuid())
  fileName String
  url      String // In a real app, this might point to a cloud storage URL
  size     Int
  type     String?
  ticketId String?
  ticket   Ticket? @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  approvalRequestId String?
  approvalRequest   ApprovalRequest? @relation(fields: [approvalRequestId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([approvalRequestId])
}

enum InventoryItemCategory {
  Computadora
  Monitor
  Teclado
  Mouse
  Impresora
  Escaner
  Router
  Switch
  Servidor
  Laptop
  Tablet
  Proyector
  TelefonoIP // Prisma enums cannot have spaces
  OtroPeriferico
  Software
  Licencia
  Otro
}

enum InventoryItemStatus {
  EnUso // Prisma enums cannot have spaces
  EnAlmacen
  EnReparacion
  DeBaja
  Perdido
}

enum RamOption {
  NoEspecificado
  RAM_2GB @map("2GB")
  RAM_4GB @map("4GB")
  RAM_8GB @map("8GB")
  RAM_12GB @map("12GB")
  RAM_16GB @map("16GB")
  RAM_32GB @map("32GB")
  RAM_64GB @map("64GB")
  Otro
}

enum StorageType {
  HDD
  SSD
  NoEspecificado
}

model InventoryItem {
  id            String                @id @default(cuid())
  name          String
  category      InventoryItemCategory
  brand         String?
  model         String?
  serialNumber  String?               @unique
  processor     String?
  ram           RamOption?
  storageType   StorageType?
  storage       String?               // e.g., "512GB", "1TB"
  quantity      Int
  location      String?
  status        InventoryItemStatus
  notes         String?               @db.Text
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  purchaseDate  DateTime?             // Changed from String to DateTime for better querying
  supplier      String?
  warrantyEndDate DateTime?           // Changed from String to DateTime

  addedByUserId String
  addedByUser   User                  @relation("InventoryAddedByUser", fields: [addedByUserId], references: [id])
  addedByUserName String // Denormalized

  @@index([category])
  @@index([status])
  @@index([location])
  @@index([addedByUserId])
}

enum ApprovalRequestType {
  Compra
  PagoProveedor
}

enum ApprovalStatus {
  Pendiente
  Aprobado
  Rechazado
  InformacionSolicitada
}

enum PaymentType {
  Contado
  Cuotas
}

model ApprovalRequest {
  id            String              @id @default(cuid())
  type          ApprovalRequestType
  subject       String
  description   String?             @db.Text
  status        ApprovalStatus
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  requesterId   String
  requester     User                @relation("ApprovalRequestedByUser", fields: [requesterId], references: [id])
  requesterName String // Denormalized
  requesterEmail String?
  approverId    String?
  approver      User?               @relation("ApprovalApprovedByUser", fields: [approverId], references: [id])
  approverName  String?
  approverComment String?           @db.Text
  approvedAt    DateTime?
  rejectedAt    DateTime?
  infoRequestedAt DateTime?

  // Purchase specific
  itemDescription String?
  estimatedPrice  Float?
  supplierCompra  String?
  // Payment specific
  supplierPago     String?
  totalAmountToPay Float?
  approvedAmount   Float?
  approvedPaymentType PaymentType?
  attachments       Attachment[]
  activityLog       ApprovalActivityLogEntry[]
  paymentInstallments PaymentInstallment[]

  @@index([requesterId])
  @@index([approverId])
  @@index([status])
  @@index([type])
}

model PaymentInstallment {
  id                String   @id @default(cuid())
  amount            Float
  dueDate           DateTime
  // status         String? // Future: Pendiente, Pagado, Atrasado

  approvalRequestId String
  approvalRequest   ApprovalRequest @relation(fields: [approvalRequestId], references: [id], onDelete: Cascade)

  @@index([approvalRequestId])
}

model ApprovalActivityLogEntry {
  id                String   @id @default(cuid())
  action            String
  timestamp         DateTime @default(now())
  comment           String?  @db.Text

  userId            String // Denormalized user ID for the log
  userName          String // Denormalized user name

  approvalRequestId String
  approvalRequest   ApprovalRequest @relation(fields: [approvalRequestId], references: [id], onDelete: Cascade)

  @@index([approvalRequestId])
}


enum CasoMantenimientoStatus {
  Registrado
  PendientePresupuesto
  PresupuestoAprobado
  EnServicioReparacion @map("En Servicio/Reparación")
  PendienteRespaldo
  Resuelto
  Cancelado
}

enum CasoMantenimientoPriority {
  Baja
  Media
  Alta
  Critica @map("Crítica")
}

model CasoDeMantenimiento {
  id                       String                     @id @default(cuid())
  title                    String
  description              String                     @db.Text
  location                 String
  equipment                String?
  priority                 CasoMantenimientoPriority
  currentStatus            CasoMantenimientoStatus
  registeredAt             DateTime                   @default(now())
  assignedProviderName     String
  providerContactPerson    String?
  expectedResolutionDate   DateTime?
  lastFollowUpDate         DateTime?
  nextFollowUpDate         DateTime?
  resolutionDetails        String?                    @db.Text
  cost                     Float?
  invoicingDetails         String?                    @db.Text
  resolvedAt               DateTime?

  registeredByUserId       String
  registeredByUser         User                       @relation("CasoRegisteredByUser", fields: [registeredByUserId], references: [id])
  registeredByUserName     String // Denormalized

  log                      CasoMantenimientoLogEntry[]

  @@index([registeredByUserId])
  @@index([currentStatus])
  @@index([priority])
}

model CasoMantenimientoLogEntry {
  id                String   @id @default(cuid())
  timestamp         DateTime @default(now())
  action            String
  notes             String   @db.Text
  statusAfterAction CasoMantenimientoStatus?

  userId            String
  user              User     @relation("LogEntryByUser", fields: [userId], references: [id])
  userName          String   // Denormalized

  casoId            String
  caso              CasoDeMantenimiento @relation(fields: [casoId], references: [id], onDelete: Cascade)

  @@index([casoId])
  @@index([userId])
}

model AuditLogEntry {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())
  // CORRECCIÓN: userEmail se hace opcional para permitir onDelete: SetNull
  userEmail String?  // Email of the user performing the action

  action    String
  details   String?  @db.Text

  user      User?    @relation(fields: [userEmail], references: [email], onDelete: SetNull, onUpdate: Cascade)


  @@index([userEmail])
  @@index([action])
}